#! /usr/bin/perl

#*****************************************************************************
# IrstLM: IRST Language Model Toolkit
# Copyright (C) 2007 Marcello Federico, ITC-irst Trento, Italy

# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.

# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

#******************************************************************************
#merge prefix LMs into one single file

use strict;
use Getopt::Long "GetOptions";
use File::Basename;
use File::Copy qw(move);

my ($lm,$size,$sublm,$backoff)=();
my ($verbose,$help)=();
my ($gzip,$gunzip,$zipping)=();

$help=0;
$backoff=0;

&GetOptions('size=i' => \$size,
'lm=s' => \$lm,
'sublm=s' => \$sublm,
'backoff' => \$backoff,
'zipping' => \$zipping,
'v|verbose' => \$verbose,
'h|help' => \$help);

if ($help || !$size || !$lm || !$sublm) {
	my $cmnd = basename($0);
  print "\n$cmnd - merge single LMs\n",
	"\nUSAGE:\n",
	"       $cmnd [options]\n",
	"\nOPTIONS:\n",
	"       --size <int>          maximum n-gram size for the language model\n",
	"       --sublm <string>      path identifying all input prefix sub LMs\n",
	"       --lm <string>         name of the output LM file (will be gzipped if parameter '--zipping' is set)\n",
	"       --backoff						  (optional) create a backoff LM, output is directly in ARPA format (default is false, i.e. iARPA format) \n",
	"       --zipping             (optional) enable usage of zipped temporary files (disabled by default)\n",
    "       -v, --verbose         (optional) print debugging info on stderr\n",
	"       -h, --help            (optional) print these instructions\n",
	"\n";

  exit(1);
}

if ($zipping){
  $gzip=`which gzip 2> /dev/null`;
  $gunzip=`which gunzip 2> /dev/null`;
  chomp($gzip);
  chomp($gunzip);
}

print STDERR "merge-sublm.pl --size $size --sublm $sublm --lm $lm --backoff $backoff --$zipping\n" if ($verbose);

print STDERR "Compute total sizes of n-grams\n" if ($verbose);

my @size=();          #number of n-grams for each level
my $tot1gr=0;         #total frequency of 1-grams
my $unk=0;            #frequency of <unk>
my $pr;               #probability of 1-grams
my (@files,$files);   #sublm files for a given n-gram size  

for (my $n=1;$n<=$size;$n++){

  @files=map { glob($_) } "${sublm}*.${n}gr*";
  $files=join(" ",@files);
  $files || die "cannot find sublm files\n";
  print STDERR "join files $files\n" if ($verbose);
  
  if ($n==1){
    my ${tmp_open}="";
    if ($zipping){ $tmp_open="$gunzip -c $files|"; }else{ $tmp_open="cat $files|"; }
    print STDERR "opening (concatenated) ${files}\n" if ($verbose);
    open(INP,"$tmp_open") || die "cannot open $files\n";

    while(my $line = <INP>){
      $size[$n]++;
      chomp($line);
      print STDERR "there is an empty line in any of these files ($files); this should not happen\n" if ($line =~ /^$/) && ($verbose);
      my @words = split(/[ \t]+/,$line);
      #cut down counts for sentence initial
      $words[0]=1 if $words[1]=~/<s>/;
      #there could be more independent <unk> words
      #generated by ngt with -sd option
      $size[$n]-- if $unk && $words[1] eq "<unk>";
      $unk+=$words[0] if $words[1]=~/<unk>/i;
      $tot1gr+=$words[0];
    }
    print STDERR "closing (concatenated) ${files}\n" if ($verbose);
    close(INP);
    if ($unk==0){
      print STDERR "implicitely add <unk> word to counters\n" if ($verbose);
      $tot1gr+=$size[$n]; #equivalent to WB smoothing
      $size[$n]++; 
    }
  }else{
    for (my $j=0;$j<scalar(@files);$j++){
      if ($zipping){
        safesystem("$gunzip -c $files[$j] | grep -v '10000.000' | wc -l > wc$$") or die;
      }else{
        safesystem("cat $files[$j] | grep -v '10000.000' | wc -l > wc$$") or die;
      }
      print STDERR "opening wc$$\n" if ($verbose);
      open(INP,"wc$$") || die "cannot open wc$$\n";
      my $wc = <INP>;
      chomp($wc);
      $size[$n] += $wc;
      print STDERR "closing wc$$\n" if ($verbose);
      close(INP);
      print STDERR "removing wc$$\n" if ($verbose);
      unlink("wc$$");
    }
  }
  print STDERR "n:$n size:$size[$n] unk:$unk\n" if ($verbose);
}

print STDERR "Merge all sub LMs\n" if ($verbose);

my (${tmp_lm})=();
if ($zipping){ $lm.=".gz" if $lm!~/.gz$/; }
unlink("${lm}.tmp");
if ($zipping){ ${tmp_lm}="|$gzip -c >> ${lm}.tmp"; }else{ ${tmp_lm}=">> ${lm}.tmp"; };

print STDERR "opening |${tmp_lm}|\n" if ($verbose);
print STDERR "opening ${lm}.tmp to print the header of the ARPA format\n" if ($verbose);
open(LM,"${tmp_lm}") || die "Cannot open ${lm}.tmp\n";

print STDERR "Write LM Header\n" if ($verbose);
if ($backoff){
	printf LM "ARPA\n\n";
} else{
	printf LM "iARPA\n\n";
}

printf LM "\\data\\\n";
for (my $n=1;$n<=$size;$n++){
    printf LM "ngram $n=\t$size[$n]\n";
}
printf LM "\n";

print STDERR "closing ${lm}.tmp\n" if ($verbose);
close(LM);;

print STDERR "Writing LM Tables\n" if ($verbose);
for (my $n=1;$n<=$size;$n++){
  
  print STDERR "Level $n\n" if ($verbose);
  
  @files=map { glob($_) } "${sublm}*.${n}gr*";
  $files=join(" ",@files);
  print STDERR "input from: $files\n" if ($verbose);
  my $tmp_open="";      
  if ($n==1){
    if ($zipping){ ${tmp_open}="$gunzip -c $files|"; }else{ $tmp_open="cat $files|"; }
    print STDERR "opening (concatenated) input files ${tmp_open}\n" if ($verbose);
    open(INP,"${tmp_open}") || die "cannot open $files\n";

    print STDERR "re-opening output file ${lm}.tmp to print 1-grams\n" if ($verbose);
    open(LM,"${tmp_lm}");

    printf LM "\\$n-grams:\n";
    while (my $line = <INP>){
      chomp($line);
      print STDERR "there is an empty line in any of these files ($files); this should not happen\n" if ($line =~ /^$/) && ($verbose);
	  #lowercase some expressions of google n-grams
      $line=~s/<S>/<s>/g;
      $line=~s/<\/S>/<\/s>/g;
      $line=~s/<UNK>/<unk>/g;

      my @words = split(/[ \t]+/,$line);

      #always print unk a the eqnd
      next if $words[1]=~/<unk>/i;

      #cut down counts for sentence initial
      $words[0]=1 if $words[1]=~/<s>/i;	  
	  	
      #apply witten-bell smoothing on 1-grams
      $pr=(log($words[0]+1)-log($tot1gr+$size[1]))/log(10.0);
      shift @words;
      printf LM "%f\t%s\t%f\n",$pr,$words[0],$words[1];
    }
    print STDERR "closing (concatenated input files\n" if ($verbose);
    close(INP);

    #print final <unk>
    #witten-bell smoothing of <unk> probability
    if ($unk){
      $pr=(log($unk+1)-log($tot1gr+$size[1]))/log(10.0);
    }else{
      $pr=(log($size[1]-1+1)-log($tot1gr+$size[1]))/log(10.0);
    }

    printf LM "%f <unk>\n",$pr;
    print STDERR "re-closing output file ${lm}.tmp\n" if ($verbose);
    close(LM);;
  }else{
    print STDERR "re-opening output file for adding symbol of the ARPA format\n" if ($verbose);
    open(LM,"${tmp_lm}") || die "Cannot open ${lm}.tmp\n";

    printf LM "\\$n-grams:\n";
    print STDERR "re-closing output file ${lm}.tmp\n" if ($verbose);
    close(LM);
    print STDERR "copying n-grams (n>1) into ${lm}.tmp removing entries with undefined prob\n" if ($verbose);
    for (my $j=0;$j<scalar(@files);$j++){
      next if ! -s $files[$j]; #skip if it has size 0, note that the file surely exists)
      if ($zipping){
        safesystem("$gunzip -c $files[$j] | grep -v '10000.000' | gzip -c >> ${lm}.tmp") or die;
      }else{
        safesystem("cat $files[$j] | grep -v '10000.000' >> ${lm}.tmp") or die;
      };
    }
  }
}

print STDERR "re-opening output file ${lm}.tmp for adding final symbol of the ARPA format\n" if ($verbose);
open(LM,"${tmp_lm}") || die "Cannot open ${lm}.tmp\n";
printf LM "\\end\\\n";
print STDERR "re-closing output file ${lm}.tmp\n" if ($verbose);
close(LM);

print STDERR "renaming ${lm}.tmp into ${lm}\n" if ($verbose);
move("${lm}.tmp","${lm}");

sub safesystem {
  print STDERR "Executing: @_\n";
  system(@_);
  if ($? == -1) {
      print STDERR "Failed to execute: @_\n  $!\n";
      exit(1);
  }
  elsif ($? & 127) {
      printf STDERR "Execution of: @_\n  died with signal %d, %s coredump\n",
          ($? & 127),  ($? & 128) ? 'with' : 'without';
      exit(1);
  }
  else {
    my $exitcode = $? >> 8;
    print STDERR "Exit code: $exitcode\n" if $exitcode;
    return ! $exitcode;
  }
}

